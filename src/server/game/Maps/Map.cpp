/*
 * This file is part of the AzerothCore Project. See AUTHORS file for Copyright information
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation; either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "Map.h"
#include "Battleground.h"
#include "CellImpl.h"
#include "Chat.h"
#include "DisableMgr.h"
#include "DynamicTree.h"
#include "GameTime.h"
#include "Geometry.h"
#include "GridNotifiers.h"
#include "Group.h"
#include "InstanceScript.h"
#include "IVMapMgr.h"
#include "LFGMgr.h"
#include "MapGrid.h"
#include "MapInstanced.h"
#include "Metric.h"
#include "MiscPackets.h"
#include "MMapFactory.h"
#include "Object.h"
#include "ObjectAccessor.h"
#include "ObjectMgr.h"
#include "Pet.h"
#include "ScriptMgr.h"
#include "Transport.h"
#include "VMapFactory.h"
#include "Vehicle.h"
#include "VMapMgr2.h"
#include "Weather.h"
#include "WeatherMgr.h"
#include "WorkStealingScheduler.h"

#define MAP_INVALID_ZONE        0xFFFFFFFF

ZoneDynamicInfo::ZoneDynamicInfo() : MusicId(0), DefaultWeather(nullptr), WeatherId(WEATHER_STATE_FINE),
                                     WeatherGrade(0.0f), OverrideLightId(0), LightFadeInTime(0) { }

Map::~Map()
{
    // UnloadAll must be called before deleting the map

    sScriptMgr->OnDestroyMap(this);

    if (!m_scriptSchedule.empty())
        sScriptMgr->DecreaseScheduledScriptCount(m_scriptSchedule.size());

    MMAP::MMapFactory::createOrGetMMapMgr()->unloadMapInstance(GetId(), i_InstanceId);
}

Map::Map(uint32 id, uint32 InstanceId, uint8 SpawnMode, Map* _parent) :
    _mapGridManager(this), i_mapEntry(sMapStore.LookupEntry(id)), i_spawnMode(SpawnMode), i_InstanceId(InstanceId),
    m_unloadTimer(0), m_VisibleDistance(DEFAULT_VISIBILITY_DISTANCE), _instanceResetPeriod(0),
    _transportsUpdateIter(_transports.end()), i_scriptLock(false), _defaultLight(GetDefaultMapLight(id))
{
    m_parentMap = (_parent ? _parent : this);

    _zonePlayerCountMap.clear();
    _updatableObjectListRecheckTimer.SetInterval(UPDATABLE_OBJECT_LIST_RECHECK_TIMER);

    //lets initialize visibility distance for map
    Map::InitVisibilityDistance();

    _weatherUpdateTimer.SetInterval(1 * IN_MILLISECONDS);
    _corpseUpdateTimer.SetInterval(20 * MINUTE * IN_MILLISECONDS);
}

// Hook called after map is created AND after added to map list
void Map::OnCreateMap()
{
    // Instances load all grids by default (both base map and child maps)
    if (GetInstanceId())
        LoadAllGrids();

    sScriptMgr->OnCreateMap(this);
}

void Map::InitVisibilityDistance()
{
    //init visibility for continents
    m_VisibleDistance = World::GetMaxVisibleDistanceOnContinents();

    switch (GetId())
    {
        case MAP_EBON_HOLD: // Scarlet Enclave (DK starting zone)
            m_VisibleDistance = 125.0f;
            break;
        case MAP_SCOTT_TEST: // (box map)
            m_VisibleDistance = 200.0f;
            break;
    }
}

// Template specialization of utility methods
template<class T>
void Map::AddToGrid(T* obj, Cell const& cell)
{
    MapGridType* grid = GetMapGrid(cell.GridX(), cell.GridY());
    grid->AddGridObject<T>(cell.CellX(), cell.CellY(), obj);

    obj->SetCurrentCell(cell);
}

template<>
void Map::AddToGrid(Creature* obj, Cell const& cell)
{
    MapGridType* grid = GetMapGrid(cell.GridX(), cell.GridY());
    grid->AddGridObject(cell.CellX(), cell.CellY(), obj);
    if (obj->IsFarVisible())
        grid->AddFarVisibleObject(cell.CellX(), cell.CellY(), obj);

    obj->SetCurrentCell(cell);
}

template<>
void Map::AddToGrid(GameObject* obj, Cell const& cell)
{
    MapGridType* grid = GetMapGrid(cell.GridX(), cell.GridY());
    grid->AddGridObject(cell.CellX(), cell.CellY(), obj);
    if (obj->IsFarVisible())
        grid->AddFarVisibleObject(cell.CellX(), cell.CellY(), obj);

    obj->SetCurrentCell(cell);
}

template<>
void Map::AddToGrid(Player* obj, Cell const& cell)
{
    MapGridType* grid = GetMapGrid(cell.GridX(), cell.GridY());
    grid->AddGridObject(cell.CellX(), cell.CellY(), obj);
}

template<>
void Map::AddToGrid(Corpse* obj, Cell const& cell)
{
    MapGridType* grid = GetMapGrid(cell.GridX(), cell.GridY());
    // Corpses are a special object type - they can be added to grid via a call to AddToMap
    // or loaded through ObjectGridLoader.
    // Both corpses loaded from database and these freshly generated by Player::CreateCoprse are added to _corpsesByCell
    // ObjectGridLoader loads all corpses from _corpsesByCell even if they were already added to grid before it was loaded
    // so we need to explicitly check it here (Map::AddToGrid is only called from Player::BuildPlayerRepop, not from ObjectGridLoader)
    // to avoid failing an assertion in GridObject::AddToGrid
    if (grid->IsObjectDataLoaded())
        grid->AddGridObject(cell.CellX(), cell.CellY(), obj);
}

template<class T>
void Map::DeleteFromWorld(T* obj)
{
    // Note: In case resurrectable corpse and pet its removed from global lists in own destructor
    delete obj;
}

template<>
void Map::DeleteFromWorld(Player* player)
{
    ObjectAccessor::RemoveObject(player);

    RemoveUpdateObject(player); //TODO: I do not know why we need this, it should be removed in ~Object anyway
    delete player;
}

void Map::EnsureGridCreated(GridCoord const& gridCoord)
{
    _mapGridManager.CreateGrid(gridCoord.x_coord, gridCoord.y_coord);
}

bool Map::EnsureGridLoaded(Cell const& cell)
{
    EnsureGridCreated(GridCoord(cell.GridX(), cell.GridY()));

    if (_mapGridManager.LoadGrid(cell.GridX(), cell.GridY()))
    {
        Balance();
        return true;
    }

    return false;
}

MapGridType* Map::GetMapGrid(uint16 const x, uint16 const y)
{
    return _mapGridManager.GetGrid(x, y);
}

bool Map::IsGridLoaded(GridCoord const& gridCoord) const
{
    return _mapGridManager.IsGridLoaded(gridCoord.x_coord, gridCoord.y_coord);
}

bool Map::IsGridCreated(GridCoord const& gridCoord) const
{
    return _mapGridManager.IsGridCreated(gridCoord.x_coord, gridCoord.y_coord);
}

void Map::LoadGrid(float x, float y)
{
    EnsureGridLoaded(Cell(x, y));
}

void Map::LoadAllGrids()
{
    for (uint32 cellX = 0; cellX < TOTAL_NUMBER_OF_CELLS_PER_MAP; cellX++)
        for (uint32 cellY = 0; cellY < TOTAL_NUMBER_OF_CELLS_PER_MAP; cellY++)
            LoadGrid((cellX + 0.5f - CENTER_GRID_CELL_ID) * SIZE_OF_GRID_CELL, (cellY + 0.5f - CENTER_GRID_CELL_ID) * SIZE_OF_GRID_CELL);
}

void Map::LoadGridsInRange(Position const& center, float radius)
{
    if (_mapGridManager.IsGridsFullyLoaded())
        return;

    float const x = center.GetPositionX();
    float const y = center.GetPositionY();

    CellCoord cellCoord(Acore::ComputeCellCoord(x, y));
    if (!cellCoord.IsCoordValid())
        return;

    if (radius > SIZE_OF_GRIDS)
        radius = SIZE_OF_GRIDS;

    CellArea area = Cell::CalculateCellArea(x, y, radius);
    if (!area)
        return;

    for (uint32 x = area.low_bound.x_coord; x <= area.high_bound.x_coord; ++x)
    {
        for (uint32 y = area.low_bound.y_coord; y <= area.high_bound.y_coord; ++y)
        {
            CellCoord cellCoord(x, y);
            Cell cell(cellCoord);
            EnsureGridLoaded(cell);
        }
    }
}

/**
 * @brief Parallel update of all players using work-stealing scheduler
 * 
 * This method divides the player list into chunks and processes them in parallel
 * using the Blumofe-Leiserson work-stealing algorithm
 */
void Map::UpdatePlayersParallel(uint32 t_diff, uint32 p_diff, Acore::WorkStealingScheduler* scheduler)
{
    if (!scheduler)
        return;

    // Collect all players into a vector for parallel processing
    std::vector<PlayerUpdateData> playerData;
    playerData.reserve(m_mapRefMgr.getSize());

    for (m_mapRefIter = m_mapRefMgr.begin(); m_mapRefIter != m_mapRefMgr.end(); ++m_mapRefIter)
    {
        Player* player = m_mapRefIter->GetSource();
        if (player && player->IsInWorld())
        {
            playerData.push_back({player, t_diff, p_diff});
        }
    }

    if (playerData.empty())
        return;

    // Define grain size - number of players processed per task
    const size_t GRAIN_SIZE = sConfigMgr->GetOption<uint32>("WorkStealing.GrainSize", 64);
    const size_t numPlayers = playerData.size();

    // Task function to update a range of players
    auto updatePlayerRange = [](void* data) 
    {
        struct TaskData
        {
            std::vector<PlayerUpdateData>* players;
            size_t start;
            size_t end;
        };

        TaskData* taskData = static_cast<TaskData*>(data);
        
        for (size_t i = taskData->start; i < taskData->end; ++i)
        {
            Player* player = (*taskData->players)[i].player;
            if (player && player->IsInWorld())
            {
                WorldObject::UpdateHelper helper(player);
                helper.Update((*taskData->players)[i].t_diff, (*taskData->players)[i].p_diff);
            }
        }

        delete taskData;
    };

    // Spawn parallel tasks for player updates
    std::vector<Acore::WorkStealingScheduler::Task*> tasks;
    
    for (size_t i = 0; i < numPlayers; i += GRAIN_SIZE)
    {
        size_t end = std::min(i + GRAIN_SIZE, numPlayers);
        
        struct TaskData
        {
            std::vector<PlayerUpdateData>* players;
            size_t start;
            size_t end;
        };

        TaskData* taskData = new TaskData{&playerData, i, end};
        
        auto* task = scheduler->Spawn(updatePlayerRange, taskData);
        tasks.push_back(task);
    }

    // Wait for all tasks to complete
    for (auto* task : tasks)
    {
        scheduler->Wait(task);
    }
}

/**
 * @brief Parallel update of creatures using work-stealing scheduler
 */
void Map::UpdateCreaturesParallel(uint32 t_diff, Acore::WorkStealingScheduler* scheduler)
{
    if (!scheduler)
        return;

    // Collect active creatures
    std::vector<CreatureUpdateData> creatureData;
    creatureData.reserve(_updatableObjectList.size());

    for (auto* obj : _updatableObjectList)
    {
        if (Creature* creature = obj->ToCreature())
        {
            if (creature->IsInWorld())
            {
                creatureData.push_back({creature, t_diff});
            }
        }
    }

    if (creatureData.empty())
        return;

    const size_t GRAIN_SIZE = sConfigMgr->GetOption<uint32>("WorkStealing.GrainSize", 64);
    const size_t numCreatures = creatureData.size();

    auto updateCreatureRange = [](void* data)
    {
        struct TaskData
        {
            std::vector<CreatureUpdateData>* creatures;
            size_t start;
            size_t end;
        };

        TaskData* taskData = static_cast<TaskData*>(data);

        for (size_t i = taskData->start; i < taskData->end; ++i)
        {
            Creature* creature = (*taskData->creatures)[i].creature;
            if (creature && creature->IsInWorld())
            {
                creature->Update((*taskData->creatures)[i].diff);
            }
        }

        delete taskData;
    };

    std::vector<Acore::WorkStealingScheduler::Task*> tasks;

    for (size_t i = 0; i < numCreatures; i += GRAIN_SIZE)
    {
        size_t end = std::min(i + GRAIN_SIZE, numCreatures);

        struct TaskData
        {
            std::vector<CreatureUpdateData>* creatures;
            size_t start;
            size_t end;
        };

        TaskData* taskData = new TaskData{&creatureData, i, end};

        auto* task = scheduler->Spawn(updateCreatureRange, taskData);
        tasks.push_back(task);
    }

    for (auto* task : tasks)
    {
        scheduler->Wait(task);
    }
}

/**
 * @brief Main Map::Update entry point - decides between parallel and sequential
 * 
 * This is the refactored Update method that checks configuration and chooses
 * the appropriate update path based on work-stealing scheduler availability
 */
void Map::Update(uint32 const t_diff, uint32 const p_diff, bool /*thread*/)
{
    // Check if work-stealing is enabled and this map has enough players
    if (sMapMgr->UseWorkStealing() && 
        m_mapRefMgr.getSize() >= sConfigMgr->GetOption<uint32>("WorkStealing.MinPlayersForParallel", 10))
    {
        UpdateParallel(t_diff, p_diff, sMapMgr->GetWorkStealingScheduler());
    }
    else
    {
        UpdateSequential(t_diff, p_diff);
    }
}

/**
 * @brief Sequential update (original implementation)
 * 
 * This contains the original Map::Update logic for when work-stealing
 * is disabled or not applicable
 */
void Map::UpdateSequential(uint32 const t_diff, uint32 const p_diff)
{
    if (t_diff)
        _dynamicTree.update(t_diff);

    // Update world sessions and players
    for (m_mapRefIter = m_mapRefMgr.begin(); m_mapRefIter != m_mapRefMgr.end(); ++m_mapRefIter)
    {
        Player* player = m_mapRefIter->GetSource();
        if (player && player->IsInWorld())
        {
            // Update session
            WorldSession* session = player->GetSession();
            MapSessionFilter updater(session);
            session->Update(p_diff, updater);

            // update players at tick
            if (!t_diff)
                player->Update(p_diff);
        }
    }

    // Xinef: creature respawn scheduler
    _creatureRespawnScheduler.Update(t_diff);

    if (!t_diff)
    {
        HandleDelayedVisibility();
        return;
    }

    _updatableObjectListRecheckTimer.Update(t_diff);
    resetMarkedCells();

    // Update players
    for (m_mapRefIter = m_mapRefMgr.begin(); m_mapRefIter != m_mapRefMgr.end(); ++m_mapRefIter)
    {
        Player* player = m_mapRefIter->GetSource();

        if (!player || !player->IsInWorld())
            continue;

        player->Update(p_diff);

        if (_updatableObjectListRecheckTimer.Passed())
        {
            MarkNearbyCellsOf(player);

            // If player is using far sight, update viewpoint
            if (WorldObject* viewPoint = player->GetViewpoint())
            {
                if (Creature* viewCreature = viewPoint->ToCreature())
                    MarkNearbyCellsOf(viewCreature);
                else if (DynamicObject* viewObject = viewPoint->ToDynObject())
                    MarkNearbyCellsOf(viewObject);
            }
        }
    }

    UpdateNonPlayerObjects(t_diff);

    SendObjectUpdates();

    ///- Process necessary scripts
    if (!m_scriptSchedule.empty())
    {
        i_scriptLock = true;
        ScriptsProcess();
        i_scriptLock = false;
    }

    MoveAllCreaturesInMoveList();
    MoveAllGameObjectsInMoveList();
    MoveAllDynamicObjectsInMoveList();

    HandleDelayedVisibility();

    // Update weather
    if (_weatherUpdateTimer.Passed())
    {
        _weatherUpdateTimer.Reset();
        for (auto& [zoneId, zoneDynamicInfo] : _zoneDynamicInfo)
        {
            if (zoneDynamicInfo.DefaultWeather)
            {
                zoneDynamicInfo.DefaultWeather->Update(t_diff);
            }
        }
    }

    // Update corpses
    if (_corpseUpdateTimer.Passed())
    {
        _corpseUpdateTimer.Reset();
        RemoveOldCorpses();
    }

    sScriptMgr->OnMapUpdate(this, t_diff);
}

/**
 * @brief Parallel update using work-stealing scheduler
 * 
 * This method coordinates parallel updates of different object types
 * using the Blumofe-Leiserson work-stealing algorithm
 */
void Map::UpdateParallel(uint32 const t_diff, uint32 const p_diff, Acore::WorkStealingScheduler* scheduler)
{
    if (!scheduler)
    {
        // Fallback to sequential update if scheduler unavailable
        UpdateSequential(t_diff, p_diff);
        return;
    }

    // Reset the scheduler's frame allocator for this update cycle
    scheduler->ResetFrame();

    // Phase 1: Sequential prerequisites
    if (t_diff)
        _dynamicTree.update(t_diff);

    // Update creature respawn scheduler
    _creatureRespawnScheduler.Update(t_diff);

    if (!t_diff)
    {
        HandleDelayedVisibility();
        return;
    }

    _updatableObjectListRecheckTimer.Update(t_diff);
    resetMarkedCells();

    // Phase 2: Parallel player updates
    UpdatePlayersParallel(t_diff, p_diff, scheduler);

    // Update marked cells after player updates
    if (_updatableObjectListRecheckTimer.Passed())
    {
        for (m_mapRefIter = m_mapRefMgr.begin(); m_mapRefIter != m_mapRefMgr.end(); ++m_mapRefIter)
        {
            Player* player = m_mapRefIter->GetSource();
            if (!player || !player->IsInWorld())
                continue;

            MarkNearbyCellsOf(player);

            if (WorldObject* viewPoint = player->GetViewpoint())
            {
                if (Creature* viewCreature = viewPoint->ToCreature())
                    MarkNearbyCellsOf(viewCreature);
                else if (DynamicObject* viewObject = viewPoint->ToDynObject())
                    MarkNearbyCellsOf(viewObject);
            }
        }
    }

    // Phase 3: Update non-player objects (can be parallelized further)
    UpdateNonPlayerObjects(t_diff);

    // Phase 4: Sequential post-processing
    SendObjectUpdates();

    if (!m_scriptSchedule.empty())
    {
        i_scriptLock = true;
        ScriptsProcess();
        i_scriptLock = false;
    }

    MoveAllCreaturesInMoveList();
    MoveAllGameObjectsInMoveList();
    MoveAllDynamicObjectsInMoveList();

    HandleDelayedVisibility();

    // Update weather
    if (_weatherUpdateTimer.Passed())
    {
        _weatherUpdateTimer.Reset();
        for (auto& [zoneId, zoneDynamicInfo] : _zoneDynamicInfo)
        {
            if (zoneDynamicInfo.DefaultWeather)
            {
                zoneDynamicInfo.DefaultWeather->Update(t_diff);
            }
        }
    }

    // Update corpses
    if (_corpseUpdateTimer.Passed())
    {
        _corpseUpdateTimer.Reset();
        RemoveOldCorpses();
    }

    sScriptMgr->OnMapUpdate(this, t_diff);
}

/**
 * @brief validate the new destination and set reachable coords
 * Check if a given path is reachable by an unit
 *
 * @param failOnCollision if true, the methods will return false when a collision occurs
 * @param failOnSlopes if true, the methods will return false when a non walkable slope is found
 *
 * @return true if the destination is valid, false otherwise
 *
 **/
bool Map::CanReachPositionAndGetValidCoords(WorldObject const* source, PathGenerator const& path, float& destX, float& destY, float& destZ, bool failOnCollision, bool failOnSlopes) const
{
    G3D::Vector3 prevPath = {source->GetPositionX(), source->GetPositionY(), source->GetPositionZ()};

    for (auto const& vector : path.GetPath())
    {
        float x = vector.x;
        float y = vector.y;
        float z = vector.z;

        if (!CanReachPositionAndGetValidCoords(source, prevPath.x, prevPath.y, prevPath.z, x, y, z, failOnCollision, failOnSlopes))
        {
            destX = x;
            destY = y;
            destZ = z;
            return false;
        }

        prevPath = vector;
    }

    destX = prevPath.x;
    destY = prevPath.y;
    destZ = prevPath.z;

    return true;
}

/**
 * @brief validate the new destination and set reachable coords
 * Check if a given unit can reach a specific point on a segment
 * and set the correct dest coords
 * NOTE: use this method with small segments.
 *
 * @param failOnCollision if true, the methods will return false when a collision occurs
 * @param failOnSlopes if true, the methods will return false when a non walkable slope is found
 *
 * @return true if the destination is valid, false otherwise
 *
 **/

bool Map::CanReachPositionAndGetValidCoords(WorldObject const* source, float& destX, float& destY, float& destZ, bool failOnCollision, bool failOnSlopes) const
{
    return CanReachPositionAndGetValidCoords(source, source->GetPositionX(), source->GetPositionY(), source->GetPositionZ(), destX, destY, destZ, failOnCollision, failOnSlopes);
}

bool Map::CanReachPositionAndGetValidCoords(WorldObject const* source, float startX, float startY, float startZ, float &destX, float &destY, float &destZ, bool failOnCollision, bool failOnSlopes) const
{
    if (!CheckCollisionAndGetValidCoords(source, startX, startY, startZ, destX, destY, destZ, failOnCollision))
    {
        return false;
    }

    Unit const* unit = source->ToUnit();
    // if it's not an unit (Object) then we do not have to continue
    // with walkable checks
    if (!unit)
    {
        return true;
    }

    /*
     * Walkable checks
     */
    bool isWaterNext = HasEnoughWater(unit, destX, destY, destZ);
    Creature const* creature = unit->ToCreature();
    bool cannotEnterWater = isWaterNext && (creature && !creature->CanEnterWater());
    bool cannotWalkOrFly = !isWaterNext && !source->ToPlayer() && !unit->CanFly() && (creature && !creature->CanWalk());
    if (cannotEnterWater || cannotWalkOrFly ||
        (failOnSlopes && !PathGenerator::IsWalkableClimb(startX, startY, startZ, destX, destY, destZ, source->GetCollisionHeight())))
    {
        return false;
    }

    return true;
}

/**
 * @brief validate the new destination and set coords
 * Check if a given unit can face collisions in a specific segment
 *
 * @return true if the destination is valid, false otherwise
 *
 **/
bool Map::CheckCollisionAndGetValidCoords(WorldObject const* source, float startX, float startY, float startZ, float &destX, float &destY, float &destZ, bool failOnCollision) const
{
    // Prevent invalid coordinates here, position is unchanged
    if (!Acore::IsValidMapCoord(startX, startY, startZ) || !Acore::IsValidMapCoord(destX, destY, destZ))
    {
        LOG_FATAL("maps", "Map::CheckCollisionAndGetValidCoords invalid coordinates startX: {}, startY: {}, startZ: {}, destX: {}, destY: {}, destZ: {}", startX, startY, startZ, destX, destY, destZ);
        return false;
    }

    bool isWaterNext = IsInWater(source->GetPhaseMask(), destX, destY, destZ, source->GetCollisionHeight());

    PathGenerator path(source);

    // Use a detour raycast to get our first collision point
    path.SetUseRaycast(true);
    bool result = path.CalculatePath(startX, startY, startZ, destX, destY, destZ, false);

    Unit const* unit = source->ToUnit();
    bool notOnGround = path.GetPathType() & PATHFIND_NOT_USING_PATH
        || isWaterNext || (unit && unit->IsFlying());

    // Check for valid path types before we proceed
    if (!result || (!notOnGround && path.GetPathType() & ~(PATHFIND_NORMAL | PATHFIND_SHORTCUT | PATHFIND_INCOMPLETE | PATHFIND_FARFROMPOLY_END)))
    {
        return false;
    }

    G3D::Vector3 endPos = path.GetPath().back();
    destX = endPos.x;
    destY = endPos.y;
    destZ = endPos.z;

    // collision check
    bool collided = false;

    // check static LOS
    float halfHeight = source->GetCollisionHeight() * 0.5f;

    // Unit is not on the ground, check for potential collision via vmaps
    if (notOnGround)
    {
        bool col = VMAP::VMapFactory::createOrGetVMapMgr()->GetObjectHitPos(source->GetMapId(),
            startX, startY, startZ + halfHeight,
            destX, destY, destZ + halfHeight,
            destX, destY, destZ, -CONTACT_DISTANCE);

        destZ -= halfHeight;

        // Collided with static LOS object, move back to collision point
        if (col)
        {
            collided = true;
        }
    }

    // check dynamic collision
    bool col = source->GetMap()->GetObjectHitPos(source->GetPhaseMask(),
        startX, startY, startZ + halfHeight,
        destX, destY, destZ + halfHeight,
        destX, destY, destZ, -CONTACT_DISTANCE);

    destZ -= halfHeight;

    // Collided with a gameobject, move back to collision point
    if (col)
    {
        collided = true;
    }

    float groundZ = VMAP_INVALID_HEIGHT_VALUE;
    source->UpdateAllowedPositionZ(destX, destY, destZ, &groundZ);

    // position has no ground under it (or is too far away)
    if (groundZ <= INVALID_HEIGHT && unit && !unit->CanFly())
    {
        // fall back to gridHeight if any
        float gridHeight = GetGridHeight(destX, destY);
        if (gridHeight > INVALID_HEIGHT)
        {
            destZ = gridHeight + unit->GetHoverHeight();
        }
        else
        {
            return false;
        }
    }

    return !failOnCollision || !collided;
}

void Map::LoadCorpseData()
{
    CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CORPSES);
    stmt->SetData(0, GetId());
    stmt->SetData(1, GetInstanceId());

    //        0     1     2     3            4      5          6          7       8       9        10     11        12    13          14          15         16
    // SELECT posX, posY, posZ, orientation, mapId, displayId, itemCache, bytes1, bytes2, guildId, flags, dynFlags, time, corpseType, instanceId, phaseMask, guid FROM corpse WHERE mapId = ? AND instanceId = ?
    PreparedQueryResult result = CharacterDatabase.Query(stmt);
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();
        CorpseType type = CorpseType(fields[13].Get<uint8>());
        uint32 guid = fields[16].Get<uint32>();
        if (type >= MAX_CORPSE_TYPE || type == CORPSE_BONES)
        {
            LOG_ERROR("maps", "Corpse (guid: {}) have wrong corpse type ({}), not loading.", guid, type);
            continue;
        }

        Corpse* corpse = new Corpse(type);

        if (!corpse->LoadCorpseFromDB(GenerateLowGuid<HighGuid::Corpse>(), fields))
        {
            delete corpse;
            continue;
        }

        AddCorpse(corpse);

        corpse->UpdatePositionData();
    } while (result->NextRow());
}

void Map::DeleteCorpseData()
{
    // DELETE FROM corpse WHERE mapId = ? AND instanceId = ?
    CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CORPSES_FROM_MAP);
    stmt->SetData(0, GetId());
    stmt->SetData(1, GetInstanceId());
    CharacterDatabase.Execute(stmt);
}

std::string Map::GetDebugInfo() const
{
    std::stringstream sstr;
    sstr << std::boolalpha
        << "Id: " << GetId() << " InstanceId: " << GetInstanceId() << " Difficulty: " << std::to_string(GetDifficulty())
        << " HasPlayers: " << HavePlayers();
    return sstr.str();
}

uint32 Map::GetCreatedGridsCount()
{
    return _mapGridManager.GetCreatedGridsCount();
}

uint32 Map::GetLoadedGridsCount()
{
    return _mapGridManager.GetLoadedGridsCount();
}

uint32 Map::GetCreatedCellsInGridCount(uint16 const x, uint16 const y)
{
    return _mapGridManager.GetCreatedCellsInGridCount(x, y);
}

uint32 Map::GetCreatedCellsInMapCount()
{
    return _mapGridManager.GetCreatedCellsInMapCount();
}

std::string InstanceMap::GetDebugInfo() const
{
    std::stringstream sstr;
    sstr << Map::GetDebugInfo() << "\n"
        << std::boolalpha
        << "ScriptId: " << GetScriptId() << " ScriptName: " << GetScriptName();
    return sstr.str();
}
